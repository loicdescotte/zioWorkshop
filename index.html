<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
</head>
<body>
<textarea id="source">

class: center, middle

# Purely functional webapp with ZIO and HTTP4s

---

# Agenda

1. Introduction to ZIO
1. Coding a real service with Http4s
1. Using the true power of ZIO
1. Streaming with FS2

---

# Introduction to ZIO

ZIO is a library for asynchronous and concurrent programming for Scala

* An IO can be Sync or Async in ZIO
* Task[A] represents an IO that produces a A and can fail with any Throwable. It is an alias of IO[Throwable, A]
* IO[E,A] represents an IO that produces a A can fail with a E

ZIO also provides some primitives like : 

* Fibers (light threads)
* Ref (concurrent state)
* Promise
* Queue
* STM
* ...

And a streams API.

---
   
# Introduction to ZIO
## Referential transparency

<img src="https://i.imgur.com/ETgzwVR.png" width="700">
    
---

# Introduction to ZIO
## Examples

What is the output of this program? 
Is `future` referentially transparent?

```scala
val future = Future(println("Hello"))

// future is eager
val program = for {
_ <- future
_ <- future
} yield()
```

Note : you can do the same test with `Try`.

---
# Introduction to ZIO
## Examples

What is the output of this program?
Is `zio` referentially transparent?

```scala
val task = zio.console.putStrLn("Hello")

// task is lazy and only describes the effects
val program =
for {
  _ <- task
  _ <- task
} yield ()

val runtime = new DefaultRuntime {}
runtime.unsafeRun(program)
```

---
# Introduction to ZIO
## zio.App

```scala
object QuickstartApp extends App {

  def run(args: List[String]) =
    program.fold(_ => 1, _ => 0)

  val program =
    for {
      _ <- putStrLn("Hello! What is your name?")
      name <- getStrLn
      _ <- putStrLn(s"Hello, ${name}, welcome to ZIO!")
    } yield ()
}
```

---
# Coding a real service with Http4s

Clone project on https://github.com/loicdescotte/zioWorkshop

---
# Coding a real service with Http4s
           
Checkout task-startPoint branch           

Add an endpoint to retrieve a stock value. Wrong values should be rejected with a status explaining the error cause

You should also display an error if the database connection is not working

Usage examples :

 * GET /stock/1 -> `{"id":1,"value":100}`
 * GET /stock/3 -> `{"Error":"Stock is empty"}`
 * GET /stock/4 -> `{"Error":"Stock not found"}`

---
# Coding a real service with Http4s

## Tips
    
ZIO : 
  * use mapError on Task to return a specific kind of error
  * use fold/foldM to handle successful and failed IOs
  * find the good methods using ZIO [scaladoc](https://javadoc.io/doc/dev.zio/zio_2.12/1.0.0-RC9) and [cheat sheet](https://github.com/ghostdogpr/zio-cheatsheet)

Doobie (database access) :
  * use `sql"...".update.run` to run an update

Circe (json) :
  * return a stock as json with Circe : `stock.asJson`
  * return an error as json : `Json.obj("Error" -> Json.fromString("Oups"))`

HTTP4s :  
  * return a 200 status with HTTP4S : `Ok(???)`
  * return a 404 status with HTTP4S : `NotFound(???)`

---
# Coding a real service with Http4s

Create the associated tests

---
# Coding a real service with Http4s

Add a POST endpoint to update a stock value with an increment, and return the new value
    
URL example (add 2 stocks for stock id 1) : /stock/1/2 

---
# Using the true power of ZIO

Replace `Task[A]` by `IO[E,A]`

---
# Using the true power of ZIO

Then replace `IO[E,A]` by `ZIO[R,E,A]` (see following slides)

---

# ZIO Environment

An IO in ZIO can take a third type parameter : `ZIO[R,E,A]` is equivalent to `IO[Any,E,A]`

The aim of this environment parameter is to ease testabilty an provide dependency injection mechanism needed to execute IOs,
for example to a database

---

# ZIO Environment
## Example

```scala
import zio.clock.Clock

trait ExtServices extends Clock {
  val stockDAO: StockDAO
}

object ExtServicesLive extends ExtServices with Clock.Live {

  override val stockDAO: StockDAO = new StockDAOLive()
}
```

In tests you can override ExtServices with a fake implementation

---

# ZIO Environment
## Access to the environment

You can inject a dependency in your application code :

```scala
val dao = ZIO.access[ExtServices](_.stockDAO)
```

---

# ZIO Environment
## Plugging your environment


```scala
object MyApp extends App {
  // program can be executed with a real or a test ExternalServices environment
  val program: ZIO[ExtServices, Throwable, Unit] = ???

  //plug the real service and eliminate the environment dependency
  override def run(args: List[String]): IO[Nothing, Int] = {
    program.provide(ExtServicesLive).fold(_ => 1, _ => 0)
  }
}
```

---

# ZIO Environment
## Plugging your environment with HTTP4s

HTTP4s needs a single parameter generic type for IO :

```scala
type STask[A] = TaskR[ExtServices, A]

//routes definition :
val routes = HttpRoutes.of[STask]

//server definition :
BlazeServerBuilder[STask]
  .bindHttp(8080, "0.0.0.0")
  //...

```

---
# Streaming with FS2

Read a file with new stock information in streaming, add the results to the db results and stream the response over HTTP


</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create();
</script>
</body>
</html>
